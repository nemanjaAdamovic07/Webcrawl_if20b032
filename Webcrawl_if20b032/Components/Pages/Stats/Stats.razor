@page "/stats"
@using Microsoft.Extensions.Logging
@using System.Text.RegularExpressions
@using Webcrawl_if20b032.Components.Services
@using Webcrawl_if20b032.Controllers
@using Webcrawl_if20b032.Domain.Files
@using Webcrawl_if20b032.Domain.Users
@using iText.Kernel.Pdf.Canvas.Parser
@using userapi.Domain
@using System;
@using System.Collections.Generic;
@using System.IO;
@using iText.Kernel.Pdf;
@using System.Linq;
@using Syncfusion.Blazor.Buttons;

@inject HttpClient httpClient
@inject AppDbContext dbcontext
@attribute [StreamRendering]


<AuthorizeView>
    <NotAuthorized>
        <span>You are not logged in. Please <a class="fw-bolder" href="/login"> click here</a> to log in.</span>
    </NotAuthorized>
    <Authorized>
        <div class="row">
            <div class="col-lg-4 offset-lg-4 pt-4 pb-4 border">
                <Microsoft.AspNetCore.Components.Forms.EditForm Model="@viewmodel" OnValidSubmit="FilterFiles" FormName="WordLookupForm" Context="wlookupContext">
                    <Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator></Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator>
                    <div class="mb-3 text-center flex-column">
                        <h3>Filter PDFs</h3>
                    </div>
                    <div class="mb-3">
                        <label>Search for a Word</label>
                        <Microsoft.AspNetCore.Components.Forms.InputText @bind-Value="viewmodel.word" class="form-control" placeholder="Searchterm">
                            <Microsoft.AspNetCore.Components.Forms.ValidationMessage For="() => viewmodel.word"></Microsoft.AspNetCore.Components.Forms.ValidationMessage>
                        </Microsoft.AspNetCore.Components.Forms.InputText>
                    </div>
                    <div class="mb-3 text-center">
                        <span class="text-danger">@errors</span>
                    </div>
                    <div class="mb-3 d-grid gap-2">
                        <button type="submit" class="btn btn-primary">Search</button><br />
                    </div>
                </Microsoft.AspNetCore.Components.Forms.EditForm>

            </div>
        </div>
        <div class="row">
            <div class="col-lg-4 offset-lg-4 pt-4 pb-4 border">
                <Microsoft.AspNetCore.Components.Forms.EditForm Model="@viewmodel" OnValidSubmit="FilterFilenames" FormName="FilenameLookup" Context="flookupContext">
                    <Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator></Microsoft.AspNetCore.Components.Forms.DataAnnotationsValidator>
                    <div class="mb-3 text-center flex-column">
                    </div>
                    <div class="mb-3">
                        <label>Search for a File</label>
                        <Microsoft.AspNetCore.Components.Forms.InputText @bind-Value="viewmodel.filename" class="form-control" placeholder="Searchterm">
                            <Microsoft.AspNetCore.Components.Forms.ValidationMessage For="() => viewmodel.filename"></Microsoft.AspNetCore.Components.Forms.ValidationMessage>
                        </Microsoft.AspNetCore.Components.Forms.InputText>
                    </div>
                    <div class="mb-3 text-center">
                        <span class="text-danger">@errors</span>
                    </div>
                    <div class="mb-3 d-grid gap-2">
                        <button type="submit" class="btn btn-primary">Search</button><br />
                    </div>
                </Microsoft.AspNetCore.Components.Forms.EditForm>

            </div>
        </div>
        @if (loading)
        {

            <h1>Loading files. This might take a while...</h1> 
        }
        else
        {
            <table class="table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Filename</th>
                        <th>Filepath</th>
                        <th>Common Words</th>
                    </tr>
                </thead>
                <tbody>
                    @if (filteredFiles.Count == 0)
                    {
                        <h2>No Files Found</h2>
                    }
                    else
                    {
                        @foreach (var file in filteredFiles)
                        {
                            <tr>
                                <td>
                                    <i class="bi bi-file-pdf"></i>
                                </td>
                                <td>@file.FileName</td>
                                <td><a href="@file.Filepath">@file.Filepath</a></td>
                                <td>
                                    <p>
                                        @foreach (var kvp in file.commonwords)
                                        {
                                            if (kvp.Key == viewmodel.word)
                                            {
                                                <text> <b>@kvp.Key.ToString(): @kvp.Value.ToString(); </b> </text> <br />

                                            }
                                            else
                                            {
                                                <text>@kvp.Key.ToString(): @kvp.Value.ToString();</text> <br />

                                            }
                                        }

                                    </p>
                                </td>
                            </tr>
                        }
                    }

                </tbody>
            </table>
        }
    </Authorized>
</AuthorizeView>




@code {
    [CascadingParameter]
    public HttpContext? httpContext { get; set; }
    [SupplyParameterFromForm]
    private StatsViewModel viewmodel { get; set; } = new();

    private static string errors { get; set; } = "";
    private static List<string> filenames { get; set; } = new();
    private static List<FileModel> userFiles { get; set; } = new();
    private static List<FileModel> filteredFiles { get; set; } = new();
    private static bool loading = false;

    private async Task FilterFiles()
    {
        string ws = viewmodel.word;
        if (ws.Length < 1)
        {
            filteredFiles = userFiles;
            return;
        }
        else if (ws.Split(" ").Length > 1)
        {
            errors = "Please use only one searchterm!";
            return;
        }

        filteredFiles = filteredFiles.Where(f => f.commonwords.ContainsKey(ws)).ToList();
        return;


    }
    private async Task FilterFilenames()
    {
        string ws = viewmodel.filename;
        if (ws.Length < 1)
        {
            filteredFiles = userFiles;
            return;
        }
        else if (ws.Split(" ").Length > 1)
        {
            errors = "Please use only one searchterm!";
            return;
        }

        filteredFiles = filteredFiles.Where(f => f.FileName.Contains(ws)).ToList();
        return;


    }
    protected override async Task OnInitializedAsync()
    {
        loading = true;
        await Task.Delay(1);
        filteredFiles = new List<FileModel>();
        userFiles = new List<FileModel>();
        filteredFiles.RemoveAll(s => true);
        userFiles.RemoveAll(s => true);
        string user = (httpContext.User.Claims.FirstOrDefault(s => true).ToString().Split("emailaddress:")[1].Trim());
        if (!Directory.Exists("/app/files/" + user))
        {
            Directory.CreateDirectory("/app/files/" + user);
        }
        string path = "/app/files/" + user;
        string[] filepaths = Directory.GetFiles(path);
        foreach (string s in filepaths)
        {
            string[] singlefilepath = new string[1] { s };
            filenames.Add(Path.GetFileName(s));
            var res = await GetTopWordsFromPdfFiles(singlefilepath);

            userFiles.Add(new FileModel(s, Path.GetFileName(s), res));
        }

        filteredFiles = userFiles;
        loading = false;

    }
    public static async Task<Dictionary<string, int>> GetTopWordsFromPdfFiles(string[] pdfFilePaths)
    {

        var wordCount = new Dictionary<string, int>();

        foreach (var pdfFilePath in pdfFilePaths)
        {
            // Extract text from PDF
            string text = await ExtractTextFromPdf(pdfFilePath);

            // Tokenize text into words
            string[] words = await TokenizeText(text);

            // Count word frequency
            await CountWordFrequency(words, wordCount);
        }

        // Sort by frequency and take the top 10
        var topWords = wordCount.OrderByDescending(pair => pair.Value)
                                .Take(10)
                                .ToDictionary(pair => pair.Key, pair => pair.Value);

        return topWords;
    }

    private static async Task<string> ExtractTextFromPdf(string pdfFilePath)
    {
        await Task.Delay(1);
        using (PdfReader reader = new PdfReader(pdfFilePath))
        {
            using (PdfDocument pdf = new PdfDocument(reader))
            {
                string text = "";

                for (int i = 1; i <= pdf.GetNumberOfPages(); i++)
                {
                    text += PdfTextExtractor.GetTextFromPage(pdf.GetPage(i));
                }

                return text;
            }
        }
    }

    private static async Task<string[]> TokenizeText(string text)
    {
        // Simple tokenization by splitting on whitespace
        await Task.Delay(1);
        return text.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
    }

    private static async Task CountWordFrequency(string[] words, Dictionary<string, int> wordCount)
    {
        await Task.Delay(1);
        foreach (var word in words)
        {
            if (word.Length > 4)
            {
                string cleanedWord = word.ToLower().Trim();

                if (!string.IsNullOrWhiteSpace(cleanedWord))
                {
                    if (wordCount.ContainsKey(cleanedWord))
                    {
                        wordCount[cleanedWord]++;
                    }
                    else
                    {
                        wordCount[cleanedWord] = 1;
                    }
                }
            }

        }
    }
}
